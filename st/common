# -*- sh -*-
###
### Common code used by st/t_* scripts.
###

set -eu -o pipefail
set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

H0=$H0_SRC_DIR/scripts/h0

. $H0_SRC_DIR/scripts/functions

# NOTE: There is no point in using `report_and_exit` when it is known
# in advance that the exit code will be non-zero. Use `die` or `exit`
# in such cases.
report_and_exit() {
    [ $# -eq 2 ] || die "${FUNCNAME[0]}: Invalid usage"
    local name=$1
    local rc=$2

    if [ $rc -eq 0 ]; then
        # This message is used by Jenkins CI as test success criteria;
        # it must appear on stdout.
        echo "$name: test status: SUCCESS"
    else
        echo "$name: FAILURE $rc" >&2
    fi
    exit $rc
}

cluster_bootstrap() {
    hctl mero bootstrap --verbose

    # Display bootstrap progress, usually it completes under a minute.
    watch hctl mero status &
    sleep 90
    kill %watch
    reset  # `kill %watch` might have left the terminal broken

    local rc=0
    # Possible failure of m0t1fs has no impact on exit code of
    # `hctl mero bootstrap` command above.
    if hctl mero status | grep -q failed; then
        rc=1
    else
        _wait_for_m0t1fs $(_m0t1fs_hosts)
    fi

    hctl mero status
    return $rc
}

check_drive_state() {
    [ $# -eq 2 ] || die "${FUNCNAME[0]}: Invalid usage"
    local expected="$1"
    local serial="$2"
    local actual

    actual=$(hctl debug print drive --serial $serial | sed -n 's/^  state: //p')
    [ "$actual" = "$expected" ]
}

wait_for_drive_state() {
    [ $# -eq 2 ] || die "${FUNCNAME[0]}: Invalid usage"
    local state="$1"
    local serial="$2"

    set +x  # silence the loop
    until check_drive_state "$@"; do
        :
    done
    set -x
    hctl mero status -d
}

wait_for_fid_state() {
    local fid="$1"
    local expected="$2"
    local steps_left=75

    set +x  # silence the loop
    echo -n "Waiting for $fid to become $expected ..."
    local state=$(hctl mero status | grep $fid | awk '{print $2}' | head -c-2)
    while [[ $state != $expected ]]; do
        sleep 3
        echo -n '.'
        ((--steps_left > 0)) || report_and_exit ${0##*/} 1
        state=$(hctl mero status | grep $fid | awk '{print $2}' | head -c-2)
    done
    echo ' done'
    set -x
}

# ----------------------------------------------------------------------
# Auxiliary functions
# (system tests are not supposed to use them directly)

## Outputs comma-separated list of hosts with m0t1fs mountpoints.
_m0t1fs_hosts() {
    if [[ -n $M0_CLUSTER ]]; then
        cat $M0_CLUSTER | python -c '
from __future__ import print_function
import sys
import yaml

cfg = yaml.safe_load(sys.stdin)
hosts = set(cfg.get("clients", []))
if hosts:
    print(",".join(hosts))
'
    else
        hostname
    fi
}

## Waits for m0t1fs to mount.
_wait_for_m0t1fs() {
    [[ $# > 0 ]] || return 0  # no m0t1fs clients

    local _sh="pdsh -S -w $*"
    if [[ $* == $(hostname) ]]; then
        _sh='bash -c'  # single-node
    fi
    local steps_left=30

    set +x  # silence the loop
    echo -n 'Waiting for m0t1fs to mount...'
    while ! $_sh 'mount | grep -q m0t1fs'; do
        sleep 2
        echo -n '.'
        ((--steps_left > 0)) || die 'Unable to mount m0t1fs'
    done
    echo ' done'
    set -x
}
