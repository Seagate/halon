{-# LANGUAGE CApiFFI #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE ExistentialQuantification  #-}
{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NamedFieldPuns #-}

-- |
-- Copyright : (C) 2013 Xyratex Technology Limited.
-- License   : All rights reserved.
--
-- Bindings to the hastate interface. This is the HA side of the notification
-- interface.
--
-- TODO: Move various message types sent through new notification
-- interface into own module or into confc package.
module Mero.Notification.HAState
  ( Note(..)
  , HAStateCallbacks(..)
  , NVec
  , HALink
  , HAMsgPtr
  , ReqId(..)
  , initHAState
  , finiHAState
  , getRPCMachine
  , notify
  , disconnect
  , delivered
  , entrypointReply
  , entrypointNoReply
  , pingProcess
  , HAMsg(..)
  , HAMsgMeta(..)
  , failureVectorReply
  , HAStateException(..)
  , ProcessEvent(..)
  , ProcessEventType(..)
  , ProcessType(..)
  , ServiceEvent(..)
  , ServiceEventType(..)
  , BEIoErr(..)
  , StobId(..)
  , StobIoOpcode(..)
  , StobIoqError(..)
  , RpcEvent(..)
  ) where

import HA.Resources.Mero.Note

import Mero.ConfC             (Cookie, Fid, Word128, ServiceType)
import Network.RPC.RPCLite    (RPCAddress(..), RPCMachine(..), RPCMachineV)

import Control.Exception      ( Exception, throwIO, SomeException, evaluate )
import Control.Monad          ( liftM2, liftM3, liftM4, void )
import Control.Monad.Catch    ( catch )

import Data.Aeson             ( ToJSON )
import Data.Binary            ( Binary )
import Data.ByteString as B   ( useAsCString )
import Data.Dynamic           ( Typeable )
import Data.Hashable          ( Hashable )
import Data.IORef             ( atomicModifyIORef, modifyIORef, IORef , newIORef )
import Data.Int
import Data.SafeCopy
import Data.Word              ( Word8, Word32, Word64 )
import Foreign.C.Types        ( CInt(..) )
import Foreign.C.String       ( CString, withCString )
import Foreign.Marshal.Alloc  ( allocaBytesAligned, alloca)
import Foreign.Marshal.Array  ( peekArray, withArrayLen, withArrayLen0, pokeArray )
import Foreign.Marshal.Utils  ( with, withMany )
import Foreign.Ptr            ( Ptr, FunPtr, freeHaskellFunPtr, nullPtr, castPtr, plusPtr )
import Foreign.Storable       ( Storable(..) )
import GHC.Generics           ( Generic )
import System.IO              ( hPutStrLn, stderr )
import System.IO.Unsafe       ( unsafePerformIO )

#include "hastate.h"

#include "be/ha.h"
#include "conf/obj.h"
#include "ha/msg.h"
#include "rpc/ha.h"
#include "stob/io.h"
#include "stob/ioq_error.h"

#let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__);}, y__)

-- | ha_msg_metadata
data HAMsgMeta = HAMsgMeta
  { _hm_fid :: Fid
  , _hm_source_process :: Fid
  , _hm_source_service :: Fid
  , _hm_time :: Word64
  } deriving (Show, Eq, Ord, Typeable, Generic)

instance Binary HAMsgMeta
instance Hashable HAMsgMeta
instance ToJSON HAMsgMeta
deriveSafeCopy 0 'base ''HAMsgMeta

data HAMsg a = HAMsg { _ha_msg_data :: a, _ha_msg_meta :: HAMsgMeta }
  deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary a => Binary (HAMsg a)
instance Hashable a => Hashable (HAMsg a)
instance ToJSON a => ToJSON (HAMsg a)
deriveSafeCopy 0 'base ''HAMsg

newtype {-# CTYPE "ha/msg.h" "const struct m0_ha_msg" #-} HAMsgPtr = HAMsgPtr (Ptr HAMsgPtr)

data {-# CTYPE "conf/ha.h" "struct m0_conf_ha_process_type" #-}
  ProcessType = TAG_M0_CONF_HA_PROCESS_OTHER
              | TAG_M0_CONF_HA_PROCESS_KERNEL
              | TAG_M0_CONF_HA_PROCESS_M0MKFS
              | TAG_M0_CONF_HA_PROCESS_M0D
              deriving (Show, Eq, Ord, Typeable, Generic)

instance Binary ProcessType
instance Hashable ProcessType
deriveSafeCopy 0 'base ''ProcessType

data {-# CTYPE "conf/ha.h" "struct m0_conf_ha_process_event" #-}
  ProcessEventType = TAG_M0_CONF_HA_PROCESS_STARTING
                   | TAG_M0_CONF_HA_PROCESS_STARTED
                   | TAG_M0_CONF_HA_PROCESS_STOPPING
                   | TAG_M0_CONF_HA_PROCESS_STOPPED
                   deriving (Show, Eq, Ord, Typeable, Generic)

instance Binary ProcessEventType
instance Hashable ProcessEventType
deriveSafeCopy 0 'base ''ProcessEventType

data ProcessEvent = ProcessEvent
  { _chp_event :: ProcessEventType
  , _chp_type :: ProcessType
  , _chp_pid :: Word64
  } deriving (Show, Eq, Ord, Typeable, Generic)

instance Binary ProcessEvent
instance Hashable ProcessEvent
deriveSafeCopy 0 'base ''ProcessEvent

data {-# CTYPE "conf/ha.h" "struct m0_conf_ha_service_event" #-}
  ServiceEventType = TAG_M0_CONF_HA_SERVICE_STARTING
                   | TAG_M0_CONF_HA_SERVICE_STARTED
                   | TAG_M0_CONF_HA_SERVICE_STOPPING
                   | TAG_M0_CONF_HA_SERVICE_STOPPED
                   | TAG_M0_CONF_HA_SERVICE_FAILED
                   deriving (Show, Eq, Ord, Typeable, Generic)

instance Binary ServiceEventType
instance Hashable ServiceEventType
deriveSafeCopy 0 'base ''ServiceEventType

data ServiceEvent = ServiceEvent
  { _chs_event :: ServiceEventType
  , _chs_type :: ServiceType
  } deriving (Show, Eq, Ord, Typeable, Generic)

instance Binary ServiceEvent
instance Hashable ServiceEvent
deriveSafeCopy 0 'base ''ServiceEvent

data {-# CTYPE "be/ha.h" "struct m0_be_location" #-}
  BELocation =
      BE_LOC_NONE
    | BE_LOC_LOG
    | BE_LOC_SEGMENT_1
    | BE_LOC_SEGMENT_2
  deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary BELocation
instance Hashable BELocation
instance ToJSON BELocation
deriveSafeCopy 0 'base ''BELocation

data {-# CTYPE "stob/io.h" "struct m0_stob_io_opcode" #-}
  StobIoOpcode =
      SIO_INVALID
    | SIO_READ
    | SIO_WRITE
    | SIO_BARRIER
    | SIO_SYNC
  deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary StobIoOpcode
instance Hashable StobIoOpcode
instance ToJSON StobIoOpcode
deriveSafeCopy 0 'base ''StobIoOpcode

data {-# CTYPE "be/ha.h" "struct m0_be_io_err" #-}
  BEIoErr = BEIoErr {
    _ber_errcode :: Int
    -- ^ 'Int' type here is mero bug, change when mero updates this struct
    --
    -- <https://seagate.slack.com/archives/mero-halon/p1477646927007353>
  , _ber_location :: BELocation
  , _ber_io_opcode :: StobIoOpcode
  } deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary BEIoErr
instance Hashable BEIoErr
instance ToJSON BEIoErr
deriveSafeCopy 0 'base ''BEIoErr

data {-# CTYPE "stob/stob.h" "struct m0_stob_id" #-}
  StobId = StobId { _si_domain_fid :: Fid
                  , _si_fid :: Fid }
  deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary StobId
instance Hashable StobId
instance ToJSON StobId
deriveSafeCopy 0 'base ''StobId

data {-# CTYPE "stob/ioq_error.h" "struct m0_be_ioq_error" #-}
  StobIoqError = StobIoqError
    { _sie_conf_sdev :: Fid
    , _sie_stob_id :: StobId
    , _sie_fd :: Int64
    , _sie_opcode :: StobIoOpcode
    , _sie_rc :: Int64
    , _sie_offset :: Word64
    , _sie_size :: Word64
    , _sie_bshift :: Word32
    } deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary StobIoqError
instance Hashable StobIoqError
instance ToJSON StobIoqError
deriveSafeCopy 0 'base ''StobIoqError

data {-# CTYPE "rpc/ha.h" "struct m0_ha_msg_rpc" #-}
  RpcEvent = RpcEvent
    { _hmr_attempts :: Word64
    , _hmr_state :: ConfObjectState
    } deriving (Eq, Show, Ord, Typeable, Generic)

instance Binary RpcEvent
instance Hashable RpcEvent
instance ToJSON RpcEvent
deriveSafeCopy 0 'base ''RpcEvent

-- | Notes telling the state of a given configuration object
data Note = Note
    { no_id :: Fid
    , no_ostate :: ConfObjectState
    } deriving (Eq, Typeable, Generic, Show, Ord)

instance Binary Note
instance Hashable Note
deriveSafeCopy 0 'base ''Note

-- | Lists of notes
type NVec = [Note]

-- | Link to communicate with a mero process
newtype HALink = HALink (Ptr HALink)
  deriving (Show, Eq, Ord)

-- | Id of the incomming entrypoint/link connected request.
newtype ReqId = ReqId Word128
  deriving (Show, Eq, Ord)

-- | A type for hidding the type argument of 'FunPtr's
data SomeFunPtr = forall a. SomeFunPtr (FunPtr a)

-- | A reference to the list of 'FunPtr's used by the implementation
cbRefs :: IORef [SomeFunPtr]
cbRefs = unsafePerformIO $ newIORef []

-- | List of callbacks beign used by notification interface
data HAStateCallbacks = HSC
  { hscStateGet :: HALink -> Word64 -> NVec -> IO ()
    -- ^ Called when a request to get the state of some objects is
    -- received.
    --
    -- When the requested state is available, 'notify' must
    -- be called by passing the given link.
  , hscProcessEvent :: HALink -> HAMsgMeta -> ProcessEvent -> IO ()
    -- ^ Called when process event notification is received
  , hscStobIoqError :: HAMsgMeta -> StobIoqError -> IO ()
    -- ^ Called when @m0_stob_ioq_error@ is received
  , hscServiceEvent :: HAMsgMeta -> ServiceEvent -> IO ()
    -- ^ Called when service event notification is received
  , hscBeError :: HAMsgMeta -> BEIoErr -> IO ()
    -- ^ Called when error is thrown from metadata BE.
  , hscStateSet :: NVec -> IO ()
    -- ^ Called when a request to update the state of some objects is
    -- received.
  , hscFailureVector :: HALink -> Cookie -> Fid -> IO ()
    -- ^ Failure vector request.
  , hscKeepalive :: HALink -> IO ()
    -- ^ Process keepalive reply
  , hscRPCEvent :: HAMsgMeta -> RpcEvent -> IO ()
  }


-- | Starts the hastate interface.
--
-- Registers callbacks to handle arriving requests.
--
-- Must be called after 'Mero.m0_init'.
--
initHAState :: RPCAddress
            -> Fid -- ^ Process Fid
            -> Fid -- ^ Profile Fid
            -> Fid -- ^ HA Service Fid
            -> Fid -- ^ RM Service Fid
            -> HAStateCallbacks
            -> (ReqId -> Fid -> Fid -> IO ())
               -- ^ Called when a request to read current confd and rm endpoints
               -- is received.
            -> (ReqId -> HALink -> IO ())
               -- ^ Called when a new link is established.
            -> (ReqId -> HALink -> IO ())
               -- ^ Called when an old link is reconnected, may happen in case
               -- of RM service change.
            -> (HALink -> IO ())
               -- ^ The link is no longer needed by the remote peer.
               -- It is safe to call 'disconnect' when all 'notify' calls
               -- using the link have completed.
            -> (HALink -> IO ())
               -- ^ The link was removed, no other calls should be done on this link.
            -> (HALink -> Word64 -> IO ())
               -- ^ Message on the given link was delivered.
            -> (HALink -> Word64 -> IO ())
               -- ^ Message on the given link will never be delivered.
            -> IO ()
initHAState (RPCAddress rpcAddr) procFid profFid haFid rmFid hsc
            ha_state_entrypoint_cb
            ha_state_link_connected ha_state_link_reused
            ha_state_link_disconnecting ha_state_link_disconnected
            ha_state_is_delivered ha_state_is_cancelled =
    useAsCString rpcAddr $ \cRPCAddr ->
    allocaBytesAligned #{size ha_state_callbacks_t}
                       #{alignment ha_state_callbacks_t}$ \pcbs -> do
      wentry <- wrapEntryCB
      wconnected <- wrapConnectedCB
      wreused    <- wrapReconnectedCB
      wdisconnecting <- wrapDisconnectingCB
      wdisconnected <- wrapDisconnectedCB
      wisdelivered <- wrapIsDeliveredCB
      wiscancelled <- wrapIsCancelledCB
      wmsgcallback <- wrapGenericCallback
      #{poke ha_state_callbacks_t, ha_state_entrypoint} pcbs wentry
      #{poke ha_state_callbacks_t, ha_state_link_connected} pcbs wconnected
      #{poke ha_state_callbacks_t, ha_state_link_reused} pcbs wconnected
      #{poke ha_state_callbacks_t, ha_state_link_disconnecting} pcbs
         wdisconnecting
      #{poke ha_state_callbacks_t, ha_state_link_disconnected} pcbs
         wdisconnected
      #{poke ha_state_callbacks_t, ha_state_is_delivered} pcbs wisdelivered
      #{poke ha_state_callbacks_t, ha_state_is_cancelled} pcbs wiscancelled
      #{poke ha_state_callbacks_t, ha_message_callback} pcbs wmsgcallback
      modifyIORef cbRefs
        ( (SomeFunPtr wentry:)
        . (SomeFunPtr wconnected:)
        . (SomeFunPtr wreused:)
        . (SomeFunPtr wdisconnecting:)
        . (SomeFunPtr wdisconnected:)
        . (SomeFunPtr wisdelivered:)
        . (SomeFunPtr wiscancelled:)
        . (SomeFunPtr wmsgcallback:)
        )
      rc <- with procFid $ \procPtr ->
              with profFid $ \profPtr ->
                with haFid $ \haPtr ->
                  with rmFid $ \rmPtr ->
                    ha_state_init cRPCAddr procPtr profPtr haPtr rmPtr pcbs
      check_rc "initHAState" rc
  where

    msgCallback :: HALink -> HAMsgPtr -> IO ()
    msgCallback hl p@(HAMsgPtr msg) = do
      meta <- HAMsgMeta
                 <$> (#{peek struct m0_ha_msg, hm_fid} msg)
                 <*> (#{peek struct m0_ha_msg, hm_source_process} msg)
                 <*> (#{peek struct m0_ha_msg, hm_source_service} msg)
                 <*> (#{peek struct m0_ha_msg, hm_time} msg)
      let payload = #{ptr struct m0_ha_msg, hm_data} msg :: Ptr ()
      mtype <- #{peek struct m0_ha_msg_data, hed_type} payload :: IO Word64
      case mtype of
        #{const M0_HA_MSG_STOB_IOQ} -> do
             ioq <- #{peek struct m0_ha_msg_data, u.hed_stob_ioq} payload
             hscStobIoqError hsc meta ioq
             delivered hl p
        #{const M0_HA_MSG_NVEC} -> do
             let pl = #{ptr struct m0_ha_msg_data, u.hed_nvec} payload :: Ptr NVec
             vtype <- #{peek struct m0_ha_msg_nvec, hmnv_type} pl :: IO Word64
             xid   <- #{peek struct m0_ha_msg_nvec, hmnv_id_of_get} pl :: IO Word64
             nts   <- peekNote pl
             if vtype > 0
             then hscStateGet hsc hl xid nts
             else hscStateSet hsc nts
             delivered hl p
        #{const M0_HA_MSG_FAILURE_VEC_REQ} -> do
             let pl = #{ptr struct m0_ha_msg_data, u.hed_fvec_req} payload :: Ptr ()
             pool   <- #{peek struct m0_ha_msg_failure_vec_req, mfq_pool} pl
             cookie <- #{peek struct m0_ha_msg_failure_vec_req, mfq_cookie} pl
             hscFailureVector hsc hl cookie pool
             delivered hl p
        #{const M0_HA_MSG_KEEPALIVE_REP} -> do
             hscKeepalive hsc hl
             delivered hl p
        #{const M0_HA_MSG_EVENT_PROCESS} -> do
             pevent <- #{peek struct m0_ha_msg_data, u.hed_event_process} payload
             hscProcessEvent hsc hl meta pevent
             delivered hl p
        #{const M0_HA_MSG_EVENT_SERVICE} -> do
             sevent <- #{peek struct m0_ha_msg_data, u.hed_event_service} payload
             hscServiceEvent hsc meta sevent
             delivered hl p
        #{const M0_HA_MSG_EVENT_RPC} -> do
             revent <- #{peek struct m0_ha_msg_data, u.hed_event_rpc} payload
             hscRPCEvent hsc meta revent
             delivered hl p
        #{const M0_HA_MSG_BE_IO_ERR} -> do
             sevent <- #{peek struct m0_ha_msg_data, u.hed_be_io_err} payload
             hscBeError hsc meta sevent
             delivered hl p
        _ | otherwise -> do
             ha_msg_debug_print p "unsupported message"
             delivered hl p

    wrapGenericCallback = cwrapGenericCB $ \hl msg -> catch
       (msgCallback (HALink hl) (HAMsgPtr msg))
       $ \e -> hPutStrLn stderr $
                  "initHAState.wrapGenericCallback: " ++ show (e :: SomeException)

    wrapEntryCB = cwrapEntryCB $ \reqId processPtr profilePtr -> catch (do
        processFid <- peek processPtr
        profileFid <- peek profilePtr
        w128       <- peek reqId
        ha_state_entrypoint_cb (ReqId w128) processFid profileFid)
        $ \e -> hPutStrLn stderr $
                  "initHAState.wrapEntryCB: " ++ show (e :: SomeException)
    wrapConnectedCB = cwrapConnectedCB $ \wptr hl -> do
        w128 <- peek wptr
        catch (ha_state_link_connected (ReqId w128) (HALink hl)) $ \e ->
          hPutStrLn stderr $
            "initHAState.wrapConnectedCB: " ++ show (e :: SomeException)
    wrapReconnectedCB = cwrapConnectedCB $ \wptr hl -> do
        w128 <- peek wptr
        catch (ha_state_link_reused (ReqId w128) (HALink hl)) $ \e ->
          hPutStrLn stderr $
            "initHAState.wrapReconnectedCB: " ++ show (e :: SomeException)
    wrapDisconnectingCB = cwrapDisconnectingCB $ \hl ->
        catch (ha_state_link_disconnecting (HALink hl)) $ \e ->
          hPutStrLn stderr $
            "initHAState.wrapDisconnectingCB: " ++ show (e :: SomeException)
    wrapDisconnectedCB = cwrapDisconnectingCB $ \hl ->
        catch (ha_state_link_disconnected (HALink hl)) $ \e ->
          hPutStrLn stderr $
            "initHAState.wrapDisconnectedCB: " ++ show (e :: SomeException)
    wrapIsDeliveredCB = cwrapIsDeliveredCB $ \hl tag ->
        catch (ha_state_is_delivered (HALink hl) tag) $ \e ->
          hPutStrLn stderr $
            "initHAState.wrapDisconnectingCB: " ++ show (e :: SomeException)
    wrapIsCancelledCB = cwrapIsDeliveredCB $ \hl tag ->
        catch (ha_state_is_cancelled (HALink hl) tag) $ \e ->
          hPutStrLn stderr $
            "initHAState.wrapDisconnectingCB: " ++ show (e :: SomeException)

peekNote :: Ptr NVec -> IO NVec
peekNote p = do
  nr <- #{peek struct m0_ha_msg_nvec, hmnv_nr} p :: IO Word64
  let array = #{ptr struct m0_ha_msg_nvec, hmnv_arr} p
  peekArray (fromIntegral nr) array

data HAStateCallbacksV

foreign import capi ha_state_init ::
    CString -> Ptr Fid -> Ptr Fid -> Ptr Fid -> Ptr Fid -> Ptr HAStateCallbacksV -> IO CInt

foreign import ccall "wrapper" cwrapEntryCB ::
                  (Ptr Word128 -> Ptr Fid -> Ptr Fid -> IO ())
    -> IO (FunPtr (Ptr Word128 -> Ptr Fid -> Ptr Fid -> IO ()))

foreign import ccall "wrapper" cwrapDisconnectingCB ::
                  (Ptr HALink -> IO ())
    -> IO (FunPtr (Ptr HALink -> IO ()))

foreign import ccall "wrapper" cwrapConnectedCB ::
                  (Ptr Word128 -> Ptr HALink -> IO ())
    -> IO (FunPtr (Ptr Word128 -> Ptr HALink -> IO ()))

foreign import ccall "wrapper" cwrapIsDeliveredCB ::
    (Ptr HALink -> Word64 -> IO ()) -> IO (FunPtr (Ptr HALink -> Word64 -> IO ()))

foreign import ccall "wrapper" cwrapGenericCB ::
                  (Ptr HALink -> Ptr HAMsgPtr -> IO ())
    -> IO (FunPtr (Ptr HALink -> Ptr HAMsgPtr -> IO ()))

instance Storable Note where
  sizeOf _ = #{size struct m0_ha_note}
  alignment _ = #{alignment struct m0_ha_note}

  peek p = liftM2 Note
      (#{peek struct m0_ha_note, no_id} p)
      (evaluate =<< fmap (toEnum . fromIntegral)
          (#{peek struct m0_ha_note, no_state} p :: IO Word32)
      )

  poke p (Note o s) = do
      #{poke struct m0_ha_note, no_id} p o
      #{poke struct m0_ha_note, no_state} p
          (fromIntegral $ fromEnum s :: Word32)

-- Finalizes the hastate interface.
finiHAState :: IO ()
finiHAState = do
    ha_state_fini
    atomicModifyIORef cbRefs (\cbs -> ([],cbs)) >>= mapM_ freeCB
  where
    freeCB (SomeFunPtr ptr) = freeHaskellFunPtr ptr

foreign import capi safe ha_state_fini :: IO ()

-- | Notifies mero at the remote address that the state of some objects has
-- changed.
notify :: HALink -> Word64 -> NVec -> IO Word64
notify (HALink hl) idx nvec =
  allocaBytesAligned #{size struct m0_ha_msg_nvec}
                     #{alignment struct m0_ha_msg_nvec} $ \pnvec -> do
    #{poke struct m0_ha_msg_nvec, hmnv_type} pnvec (0 :: Word64)
    #{poke struct m0_ha_msg_nvec, hmnv_id_of_get} pnvec idx
    #{poke struct m0_ha_msg_nvec, hmnv_nr} pnvec
        (fromIntegral $ length nvec :: Word64)
    pokeArray (#{ptr struct m0_ha_msg_nvec, hmnv_arr} pnvec) nvec
    ha_state_notify hl pnvec

foreign import capi safe ha_state_notify :: Ptr HALink -> Ptr NVec -> IO Word64

-- | Disconnects a link.
disconnect :: HALink -> IO ()
disconnect (HALink hl) = ha_state_disconnect hl

foreign import capi ha_state_disconnect :: Ptr HALink -> IO ()

-- | Sends keepalive request to process on the given link
pingProcess :: Word128 -> HALink -> IO Word64
pingProcess req_id (HALink hl) = alloca $ \req_id_p -> do
  poke req_id_p req_id
  ha_state_ping_process hl req_id_p

foreign import capi safe ha_state_ping_process :: Ptr HALink -> Ptr Word128 -> IO Word64

-- | Type of exceptions that HAState calls can produce.
data HAStateException = HAStateException String Int
  deriving (Show,Typeable)

instance Exception HAStateException

check_rc :: String -> CInt -> IO ()
check_rc _ 0 = return ()
check_rc msg i = throwIO $ HAStateException msg $ fromIntegral i

newtype {-# CTYPE "const char*" #-} ConstCString = ConstCString CString

foreign import capi ha_entrypoint_reply
  :: Ptr Word128 -> CInt
  -> Word32 -> Ptr Fid
  -> Ptr ConstCString
  -> Word32
  -> Ptr Fid -> CString
  -> IO ()

-- | Replies an entrypoint request.
entrypointReply :: ReqId -> [Fid] -> [String] -> Int -> Fid -> String -> IO ()
entrypointReply (ReqId reqId) confdFids epNames quorum rmFid rmEp =
  withMany (withCString) epNames $ \cnames ->
    withArrayLen0 nullPtr cnames $ \_ ceps_ptr ->
      withArrayLen confdFids $ \cfids_len cfids_ptr ->
        withCString rmEp $ \crm_ep ->
          with rmFid $ \crmfid ->
            with reqId $ \reqId_ptr ->
              ha_entrypoint_reply reqId_ptr 0 (fromIntegral cfids_len) cfids_ptr
                                  (castPtr ceps_ptr) (fromIntegral quorum)
                                  crmfid crm_ep
  where
    _ = ConstCString -- Avoid unused warning for ConstCString

-- | Replies an entrypoint request as invalid.
entrypointNoReply :: ReqId -> IO ()
entrypointNoReply (ReqId reqId) = with reqId $ \reqId_ptr ->
  ha_entrypoint_reply reqId_ptr (-1) 0 nullPtr nullPtr 0 nullPtr nullPtr

-- | Replies to failure vector request
failureVectorReply :: HALink -> Cookie -> Fid -> NVec -> IO ()
failureVectorReply (HALink hl) cookie pool fvec =
  allocaBytesAligned #{size struct m0_ha_msg_failure_vec_rep}
                     #{alignment struct m0_ha_msg_failure_vec_rep} $ \ffvec -> do
    #{poke struct m0_ha_msg_failure_vec_rep, mfp_cookie} ffvec cookie
    #{poke struct m0_ha_msg_failure_vec_rep, mfp_pool} ffvec pool
    #{poke struct m0_ha_msg_failure_vec_rep, mfp_nr} ffvec
       (fromIntegral $ length fvec :: Word64)
    pokeArray (#{ptr struct m0_ha_msg_failure_vec_rep, mfp_vec} ffvec) fvec
    void $ ha_state_failure_vec_reply hl ffvec

foreign import capi ha_state_failure_vec_reply :: Ptr HALink -> Ptr () -> IO Word64

foreign import capi "hastate.h ha_state_rpc_machine" ha_state_rpc_machine :: IO (Ptr RPCMachineV)

-- | Yields the 'RPCMachine' created with 'initHAState'.
getRPCMachine :: IO (Maybe RPCMachine)
getRPCMachine = do p <- ha_state_rpc_machine
                   return $ if nullPtr == p then Nothing
                              else Just $ RPCMachine p

delivered :: HALink -> HAMsgPtr -> IO ()
delivered (HALink hl) (HAMsgPtr msg) = ha_state_delivered hl msg

foreign import capi "hastate.h ha_state_delivered" ha_state_delivered :: Ptr HALink -> Ptr HAMsgPtr -> IO ()

ha_msg_debug_print :: HAMsgPtr -> String -> IO ()
ha_msg_debug_print (HAMsgPtr msg) s = withCString s $ m0_ha_msg_debug_print msg

foreign import capi "ha/msg.h m0_ha_msg_debug_print" m0_ha_msg_debug_print :: Ptr HAMsgPtr -> CString -> IO ()

-- * Boilerplate instances

instance Enum ProcessType where
  toEnum #{const M0_CONF_HA_PROCESS_OTHER} = TAG_M0_CONF_HA_PROCESS_OTHER
  toEnum #{const M0_CONF_HA_PROCESS_KERNEL} = TAG_M0_CONF_HA_PROCESS_KERNEL
  toEnum #{const M0_CONF_HA_PROCESS_M0MKFS} = TAG_M0_CONF_HA_PROCESS_M0MKFS
  toEnum #{const M0_CONF_HA_PROCESS_M0D} = TAG_M0_CONF_HA_PROCESS_M0D
  toEnum i = error $ "ProcessType toEnum failed with " ++ show i

  fromEnum TAG_M0_CONF_HA_PROCESS_OTHER = #{const M0_CONF_HA_PROCESS_OTHER}
  fromEnum TAG_M0_CONF_HA_PROCESS_KERNEL = #{const M0_CONF_HA_PROCESS_KERNEL}
  fromEnum TAG_M0_CONF_HA_PROCESS_M0MKFS = #{const M0_CONF_HA_PROCESS_M0MKFS}
  fromEnum TAG_M0_CONF_HA_PROCESS_M0D = #{const M0_CONF_HA_PROCESS_M0D}

instance Enum ProcessEventType where
  toEnum #{const M0_CONF_HA_PROCESS_STARTING} = TAG_M0_CONF_HA_PROCESS_STARTING
  toEnum #{const M0_CONF_HA_PROCESS_STARTED} = TAG_M0_CONF_HA_PROCESS_STARTED
  toEnum #{const M0_CONF_HA_PROCESS_STOPPING} = TAG_M0_CONF_HA_PROCESS_STOPPING
  toEnum #{const M0_CONF_HA_PROCESS_STOPPED} = TAG_M0_CONF_HA_PROCESS_STOPPED
  toEnum i = error $ "ProcessEventType toEnum failed with " ++ show i

  fromEnum TAG_M0_CONF_HA_PROCESS_STARTING = #{const M0_CONF_HA_PROCESS_STARTING}
  fromEnum TAG_M0_CONF_HA_PROCESS_STARTED = #{const M0_CONF_HA_PROCESS_STARTED}
  fromEnum TAG_M0_CONF_HA_PROCESS_STOPPING = #{const M0_CONF_HA_PROCESS_STOPPING}
  fromEnum TAG_M0_CONF_HA_PROCESS_STOPPED = #{const M0_CONF_HA_PROCESS_STOPPED}

instance Enum ServiceEventType where
  toEnum #{const M0_CONF_HA_SERVICE_STARTING} = TAG_M0_CONF_HA_SERVICE_STARTING
  toEnum #{const M0_CONF_HA_SERVICE_STARTED} = TAG_M0_CONF_HA_SERVICE_STARTED
  toEnum #{const M0_CONF_HA_SERVICE_STOPPING} = TAG_M0_CONF_HA_SERVICE_STOPPING
  toEnum #{const M0_CONF_HA_SERVICE_STOPPED} = TAG_M0_CONF_HA_SERVICE_STOPPED
  toEnum #{const M0_CONF_HA_SERVICE_FAILED} = TAG_M0_CONF_HA_SERVICE_FAILED
  toEnum i = error $ "ServiceEventType toEnum failed with " ++ show i

  fromEnum TAG_M0_CONF_HA_SERVICE_STARTING = #{const M0_CONF_HA_SERVICE_STARTING}
  fromEnum TAG_M0_CONF_HA_SERVICE_STARTED = #{const M0_CONF_HA_SERVICE_STARTED}
  fromEnum TAG_M0_CONF_HA_SERVICE_STOPPING = #{const M0_CONF_HA_SERVICE_STOPPING}
  fromEnum TAG_M0_CONF_HA_SERVICE_STOPPED = #{const M0_CONF_HA_SERVICE_STOPPED}
  fromEnum TAG_M0_CONF_HA_SERVICE_FAILED = #{const M0_CONF_HA_SERVICE_FAILED}

instance Enum BELocation where
  toEnum #{const M0_BE_LOC_NONE} = BE_LOC_NONE
  toEnum #{const M0_BE_LOC_LOG} = BE_LOC_LOG
  toEnum #{const M0_BE_LOC_SEGMENT_1} = BE_LOC_SEGMENT_1
  toEnum #{const M0_BE_LOC_SEGMENT_2} = BE_LOC_SEGMENT_2
  toEnum i = error $ "BELocation toEnum failed with " ++ show i

  fromEnum BE_LOC_NONE = #{const M0_BE_LOC_NONE}
  fromEnum BE_LOC_LOG = #{const M0_BE_LOC_LOG}
  fromEnum BE_LOC_SEGMENT_1 = #{const M0_BE_LOC_SEGMENT_1}
  fromEnum BE_LOC_SEGMENT_2 = #{const M0_BE_LOC_SEGMENT_2}

instance Enum StobIoOpcode where
  toEnum #{const SIO_INVALID} = SIO_INVALID
  toEnum #{const SIO_READ} = SIO_READ
  toEnum #{const SIO_WRITE} = SIO_WRITE
  toEnum #{const SIO_BARRIER} = SIO_BARRIER
  toEnum #{const SIO_SYNC} = SIO_SYNC
  toEnum i = error $ "StobIoOpcode toEnum failed with " ++ show i

  fromEnum SIO_INVALID = #{const SIO_INVALID}
  fromEnum SIO_READ = #{const SIO_READ}
  fromEnum SIO_WRITE = #{const SIO_WRITE}
  fromEnum SIO_BARRIER = #{const SIO_BARRIER}
  fromEnum SIO_SYNC = #{const SIO_SYNC}

instance Storable BEIoErr where
  sizeOf _ = #{size struct m0_be_io_err}
  alignment _ = #{alignment struct m0_be_io_err}

  peek p = liftM3 BEIoErr
      (#{peek struct m0_be_io_err, ber_errcode} p)
      (w8ToEnum <$> (#{peek struct m0_be_io_err, ber_location} p))
      (w8ToEnum <$> (#{peek struct m0_be_io_err, ber_io_opcode} p))

  poke p (BEIoErr err loc op) = do
      #{poke struct m0_be_io_err, ber_errcode} p err
      #{poke struct m0_be_io_err, ber_location} p (enumToW8 loc)
      #{poke struct m0_be_io_err, ber_io_opcode} p (enumToW8 op)

instance Storable StobId where
  sizeOf _ = #{size struct m0_stob_id}
  alignment _ = #{alignment struct m0_stob_id}

  peek p = liftM2 StobId
    (#{peek struct m0_stob_id, si_domain_fid} p)
    (#{peek struct m0_stob_id, si_fid} p)

  poke p (StobId sdfid sfid) = do
    #{poke struct m0_stob_id, si_domain_fid} p sdfid
    #{poke struct m0_stob_id, si_fid} p sfid

instance Storable StobIoqError where
  sizeOf _ = #{size struct m0_stob_ioq_error}
  alignment _ = #{alignment struct m0_stob_ioq_error}

  peek p = do
    sdev <- (#{peek struct m0_stob_ioq_error, sie_conf_sdev} p)
    stob_id <- (#{peek struct m0_stob_ioq_error, sie_stob_id} p)
    fd <- (#{peek struct m0_stob_ioq_error, sie_fd} p)
    opcode <- w8ToEnum <$> (#{peek struct m0_stob_ioq_error, sie_opcode} p)
    rc <- (#{peek struct m0_stob_ioq_error, sie_rc} p)
    offset <- (#{peek struct m0_stob_ioq_error, sie_offset} p)
    size <- (#{peek struct m0_stob_ioq_error, sie_size} p)
    bshift <- (#{peek struct m0_stob_ioq_error, sie_bshift} p)
    return $ StobIoqError sdev stob_id fd opcode rc offset size bshift

  poke p (StobIoqError sdev stob_id fd opcode rc offset size bshift) = do
    #{poke struct m0_stob_ioq_error, sie_conf_sdev} p sdev
    #{poke struct m0_stob_ioq_error, sie_stob_id} p stob_id
    #{poke struct m0_stob_ioq_error, sie_fd} p fd
    #{poke struct m0_stob_ioq_error, sie_opcode} p (enumToW8 opcode)
    #{poke struct m0_stob_ioq_error, sie_rc} p rc
    #{poke struct m0_stob_ioq_error, sie_offset} p offset
    #{poke struct m0_stob_ioq_error, sie_size} p size
    #{poke struct m0_stob_ioq_error, sie_bshift} p bshift

instance Storable HAMsgMeta where
  sizeOf _ = #{size ha_msg_metadata_t}
  alignment _ = #{alignment ha_msg_metadata_t}

  peek p = liftM4 HAMsgMeta
      (#{peek ha_msg_metadata_t, ha_hm_fid} p)
      (#{peek ha_msg_metadata_t, ha_hm_source_process} p)
      (#{peek ha_msg_metadata_t, ha_hm_source_service} p)
      (#{peek ha_msg_metadata_t, ha_hm_time} p)

  poke p (HAMsgMeta fid' sp ss t) = do
      #{poke ha_msg_metadata_t, ha_hm_fid} p fid'
      #{poke ha_msg_metadata_t, ha_hm_source_process} p sp
      #{poke ha_msg_metadata_t, ha_hm_source_service} p ss
      #{poke ha_msg_metadata_t, ha_hm_time} p t

instance Storable ProcessEvent where
  sizeOf _ = #{size struct m0_conf_ha_process}
  alignment _ = #{alignment struct m0_conf_ha_process}

  peek p = liftM3 ProcessEvent
      (w64ToEnum <$> (#{peek struct m0_conf_ha_process, chp_event} p))
      (w64ToEnum <$> (#{peek struct m0_conf_ha_process, chp_type} p))
      (#{peek struct m0_conf_ha_process, chp_pid} p)
  poke p (ProcessEvent ev et pid) = do
      #{poke struct m0_conf_ha_process, chp_event} p (enumToW64 ev)
      #{poke struct m0_conf_ha_process, chp_type} p (enumToW64 et)
      #{poke struct m0_conf_ha_process, chp_pid} p pid

instance Storable ServiceEvent where
  sizeOf _ = #{size struct m0_conf_ha_service}
  alignment _ = #{alignment struct m0_conf_ha_service}

  peek p = liftM2 ServiceEvent
      (w64ToEnum <$> (#{peek struct m0_conf_ha_service, chs_event} p))
      (w64ToEnum <$> (#{peek struct m0_conf_ha_service, chs_type} p))

  poke p (ServiceEvent ev et) = do
      #{poke struct m0_conf_ha_service, chs_event} p (enumToW64 ev)
      #{poke struct m0_conf_ha_service, chs_type} p (enumToW64 et)

instance Storable RpcEvent where
  sizeOf _ = #{size struct m0_ha_msg_rpc}
  alignment _ = #{alignment struct m0_ha_msg_rpc}

  peek p = liftM2 RpcEvent
    (#{peek struct m0_ha_msg_rpc, hmr_attempts} p)
    (w64ToEnum <$> (#{peek struct m0_ha_msg_rpc, hmr_state} p))

  poke p (RpcEvent attempts st) = do
    #{poke struct m0_ha_msg_rpc, hmr_attempts} p attempts
    #{poke struct m0_ha_msg_rpc, hmr_state} p (enumToW64 st)

enumToW8 :: Enum a => a -> Word8
enumToW8 = fromIntegral . fromEnum

w8ToEnum :: Enum a => Word8 -> a
w8ToEnum = toEnum . fromIntegral

enumToW64 :: Enum a => a -> Word64
enumToW64 = fromIntegral . fromEnum

w64ToEnum :: Enum a => Word64 -> a
w64ToEnum = toEnum . fromIntegral
