#!/usr/bin/env bash
set -eu -o pipefail
# set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

### ------------------------------------------------------------------
### Halon helper script
###
### Installation:
###     ln -s /path/to/halon/scripts/h0 ~/bin/h0
###
### Type `h0 help' for usage.
### ------------------------------------------------------------------

die() { echo "$@" >&2; exit 1; }

H0_SRC_DIR="$(readlink -f $0)"
H0_SRC_DIR="${H0_SRC_DIR%/*/*}"

## -------------------------------------------------------------------
## Configurable section

export M0_SRC_DIR=${M0_SRC_DIR:-${H0_SRC_DIR%/*}/mero}
[[ -d $M0_SRC_DIR ]]                || die "$M0_SRC_DIR: No such directory"
[[ -d $M0_SRC_DIR/mero ]]           || die "$M0_SRC_DIR: No Mero sources found"
[[ -x $M0_SRC_DIR/mero/.libs/m0d ]] || die "$M0_SRC_DIR: Mero is not built"
## -------------------------------------------------------------------

PROG="${0##*/}"

cmd_stack() {
    cd "$H0_SRC_DIR"
    stack "$@"
}

cmd_setup() {
    cmd_stack setup
}

cmd_make() {
    PKG_CONFIG_PATH=$M0_SRC_DIR LD_LIBRARY_PATH=$M0_SRC_DIR/mero/.libs \
        MERO_ROOT=$M0_SRC_DIR \
        cmd_stack build mero-halon --ghc-options='-g -j4' --test \
        --no-run-tests "$@"
}

cmd_rebuild() {
    # XXX TODO: The script should be able to determine automatically
    # whether Mero has been updated since last Halon compilation.
    # One possible solution is to reimplement this script as a Makefile.
    cmd_stack clean rpclite
    cmd_make "$@"
}

cmd_test() {
    LD_LIBRARY_PATH=$M0_SRC_DIR/mero/.libs \
        $H0_SRC_DIR/mero-halon/$(stack path --dist-dir)/build/tests/tests "$@"
}

local_install_root() {
    cmd_stack path --local-install-root
}

_bootstrap() {
    local BIN=$(local_install_root)/bin

    cd "$M0_SRC_DIR"
    HALOND=$BIN/halond HALONCTL=$BIN/halonctl \
        HALON_SOURCES=${HALON_SOURCES:-$H0_SRC_DIR} \
        st/bootstrap.sh -c "$1"
}

cmd_start() {
    _bootstrap cluster_start
}

cmd_stop() {
    _bootstrap cluster_stop
}

check_stack_dir() {
    [ -d ~/.stack ] ||
        die "Stack environment is not configured. Run \`$PROG setup' first."
}

cmd_path() {
    check_stack_dir
    echo "halon-bin: $(local_install_root)/bin"
    echo "mero-libs: $M0_SRC_DIR/mero/.libs"
}

cmd_env() {
    check_stack_dir
    echo "export PATH=\"$(local_install_root)/bin:\$PATH\""
    echo -n "export LD_LIBRARY_PATH=\"$M0_SRC_DIR/mero/.libs"
    echo "\${LD_LIBRARY_PATH:+:\$LD_LIBRARY_PATH}\""
}

cmd_clean() {
    cmd_stack clean "$@"
}

cmd_help() {
    local RET=${1:-0}

    [ $RET -eq 0 ] && usage || usage >&2
    exit $RET
}

_exec() {
    [[ $1 =~ ^cmd_(path|env|help)$ ]] || echo "----- ${@#cmd_} -----" >&2
    "$@"
}

usage() {
    cat <<EOF
Usage: $PROG {COMMAND [OPTION]...}...

Commands:
    setup                Get the appropriate GHC to build Halon.
                         (Rarely needed.)
    make [OPTION]...     Build Halon.
                         (Use \`$PROG rebuild' if Mero was updated.)
    rebuild [OPTION]...  Clean 'rpclite' module and build Halon.
    test [OPTION]...     Run unit tests.
    start                Start cluster.
    stop                 Stop cluster.
    path                 Print out handy path information.
    env                  Print shell commands that, if evaluated, simplify
                         execution of Halon binaries located in the sources
                         directory.
    clean [OPTION]...    Clean the local packages.
    stack [OPTION]...    Run \`stack' in Halon sources directory.
    help                 Show this help and exit.

Options:
    'make', 'test', 'clean', and 'stack' commands support options of the
    Haskell Tool Stack. Type \`stack <command> --help' for the documentation.

Environment variables:
    M0_SRC_DIR    Path to Mero sources directory; defaults to '$M0_SRC_DIR'.
EOF
}

CMD=
OPTS=
while [[ $# -gt 0 ]]; do
    case "$1" in
        setup|make|rebuild|test|start|stop|path|env|clean|stack|help)
            [[ -z $CMD ]] || _exec $CMD $OPTS
            CMD=cmd_${1//-/_}
            OPTS=;;
        *)
            [[ -n $CMD ]] || {
                echo "Invalid command: $1" >&2
                die "Type \`$PROG help' for usage."
            }
            OPTS+=" $1";;
    esac
    shift
done
if [[ -n $CMD ]]; then
    _exec $CMD $OPTS
else
    cmd_help 1
fi
