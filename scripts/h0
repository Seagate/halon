#!/usr/bin/env bash
set -eu -o pipefail
# set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

### ------------------------------------------------------------------
### Halon helper script
###
### Installation:
###     ln -s /path/to/halon/scripts/h0 ~/bin/h0
###
### Type `h0 help' for usage.
### ------------------------------------------------------------------

die() { echo "$@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

H0_SRC_DIR="$(readlink -f $0)"
H0_SRC_DIR="${H0_SRC_DIR%/*/*}"

## -------------------------------------------------------------------
## Configurable section

export M0_SRC_DIR=${M0_SRC_DIR:-${H0_SRC_DIR%/*}/mero}
## -------------------------------------------------------------------

PROG="${0##*/}"
SUDO='sudo -E'

assert_mero() {
    [[ -d $M0_SRC_DIR ]]      || die "$M0_SRC_DIR: No such directory"
    [[ -d $M0_SRC_DIR/mero ]] || die "$M0_SRC_DIR: No Mero sources found"
    if [[ $# -gt 0 ]]; then
        [[ -x $M0_SRC_DIR/mero/.libs/m0d ]] ||
            die "$M0_SRC_DIR: Mero is not built"
    fi
}

cmd_setup() {
    stack setup
}

## We could have exported `h0 build` command, but don't do so
## for the following reasons:
##   1. The difference between `h0 make` and `h0 build` would be hard to
##      explain. The users would be confused if both commands were present
##      in the CLI.
##   2. `h0 make` is used by CircleCI and Jenkins CI.
##   3. `h0 make` is symmetrical to `m0 make`.
##
## Still, if we ever need this function to be exported, we better export
## `h0 stack` instead.
_stack_build() {
    assert_mero libs
    PKG_CONFIG_PATH=$M0_SRC_DIR \
        stack \
            --extra-include-dirs="$M0_SRC_DIR" \
            --extra-lib-dirs="$M0_SRC_DIR/mero/.libs" \
            build \
                --ghc-options="${GHC_OPTS:--g -j2}" \
                "$@"
}

cmd_test() {
    assert_mero libs
    LD_LIBRARY_PATH=$M0_SRC_DIR/mero/.libs \
        _stack_build --test "$@"
    # Here we are using the fact that `stack test` is a shortcut for
    # `stack build --test`.
}

cmd_make() {
    _stack_build --test --no-run-tests "$@"
}

cmd_rebuild() {
    # XXX TODO: The script should be able to determine automatically
    # whether Mero has been updated since last Halon compilation.
    # One possible solution is to reimplement this script as a Makefile.
    stack clean rpclite
    cmd_make "$@"
}

cmd_clean() {
    stack clean "$@"
}

cmd_install() {
    $SUDO $H0_SRC_DIR/scripts/install-halon-services -l
    assert_mero
    $SUDO $M0_SRC_DIR/scripts/install-mero-service -l
}

cmd_uninstall() {
    assert_mero

    case ${1:-pass} in
        -c|--clean)
            $SUDO $M0_SRC_DIR/utils/m0setup --halon-facts --cleanup
            $SUDO systemctl start halon-cleanup
            $SUDO systemctl start mero-cleanup;;
        pass) ;;
        *) warn "[uninstall] Unknown option: $1";;
    esac

    $SUDO $M0_SRC_DIR/scripts/install-mero-service -u
    $SUDO $H0_SRC_DIR/scripts/install-halon-services -u
}

cmd_start() {
    cmd_uninstall
    cmd_install
    $SUDO systemctl start halon-cleanup
    $SUDO $M0_SRC_DIR/utils/m0setup --halon-facts --cleanup
    $SUDO $M0_SRC_DIR/utils/m0setup --halon-facts --clovis-apps
    $SUDO systemctl start halond
    halonctl mero bootstrap --verbose

    # Display bootstrap progress, usually it completes under a minute.
    { sleep 70; pkill -x watch; } &
    watch halonctl mero status

    local rc=0
    # Possible failure of m0t1fs has no impact on exit code of
    # `halonctl mero bootstrap` command above.
    if halonctl mero status | grep -q failed; then
        rc=1
    fi

    # Show final status (`watch` clears it's output after exit).
    halonctl mero status
    return $rc
}

cmd_stop() {
    halonctl mero stop
    halonctl mero status
    $SUDO systemctl stop halond
    $SUDO systemctl stop mero-kernel

    case ${1:-pass} in
        -u|--uninstall) cmd_uninstall --clean;;
        pass) ;;
        *) warn "[stop] Unknown option: $1";;
    esac
}

cmd_path() {
    assert_mero libs

    [ -d ~/.stack ] ||
        die "Stack environment is not configured. Run \`$PROG setup' first."
    echo "halon-bin: $(stack path --local-install-root)/bin"
    echo "mero-libs: $M0_SRC_DIR/mero/.libs"
}

cmd_help() {
    local RET=${1:-0}

    [ $RET -eq 0 ] && usage || usage >&2
    exit $RET
}

_exec() {
    [[ $1 =~ ^cmd_(path|help)$ ]] || echo "----- ${@#cmd_} -----" >&2
    "$@"
}

usage() {
    cat <<EOF
Usage: $PROG {COMMAND [OPTION]...}...

Commands:
    setup                Get the appropriate GHC to build Halon.
                         (Rarely needed.)
    make [OPTION]...     Build Halon.
                         (Use \`$PROG rebuild' if Mero was updated.)
    rebuild [OPTION]...  Clean 'rpclite' module and build Halon.
    test [OPTION]...     Run unit tests.  See 'Examples' below.
    clean [OPTION]...    Clean local packages.
    start                Start cluster.
    stop [-u]            Stop cluster. \`stop -u' is equivalent to
                         \`stop uninstall -c'.
    install              Install Mero/Halon services and binaries.
    uninstall [-c]       Uninstall Mero/Halon services and binaries.
                         If \`-c' option is provided, clean Mero/Halon
                         metadata and configuration files before
                         uninstalling services.
    path                 Print out handy path information.
    help                 Show this help and exit.

Options:
    'make', 'test', and 'clean' commands support options of the Haskell Tool
    Stack.  Type \`stack <command> --help' for documentation.

Environment variables:
    M0_SRC_DIR    Path to Mero sources directory; defaults to '$M0_SRC_DIR'.

Examples:

    # Run 'RC*' tests of 'mero-halon' package.
    $PROG test mero-halon --ta '-p RC'

    $PROG make --no-test --dry-run

    $PROG test --help
EOF
}

cd "$H0_SRC_DIR"

CMD=
OPTS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        setup|make|rebuild|test|path|clean|help) ;& # fall through
        install|uninstall|start|stop)
            [[ -z $CMD ]] || {
                if [[ ${#OPTS[@]} == 0 ]]; then
                    _exec $CMD
                else
                    _exec $CMD "${OPTS[@]}"
                fi
            }
            CMD=cmd_${1//-/_}
            OPTS=();;
        *)
            [[ -n $CMD ]] || {
                echo "Invalid command: $1" >&2
                die "Type \`$PROG help' for usage."
            }
            OPTS+=("$1");;
    esac
    shift
done
[[ -n $CMD ]] || cmd_help 1  # exits
if [[ ${#OPTS[@]} == 0 ]]; then
    _exec $CMD
else
    _exec $CMD "${OPTS[@]}"
fi
