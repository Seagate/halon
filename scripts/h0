#!/usr/bin/env bash
set -eu -o pipefail
# set -x
export PS4='+ [${FUNCNAME[0]:+${FUNCNAME[0]}:}${LINENO}] '

### ------------------------------------------------------------------
### Halon helper script
###
### Installation:
###     ln -s /path/to/halon/scripts/h0 ~/bin/h0
###
### Type `h0 help' for usage.
### ------------------------------------------------------------------

die() { echo "$@" >&2; exit 1; }
warn() { echo "*WARNING* $@" >&2; }

H0_SRC_DIR="$(readlink -f $0)"
H0_SRC_DIR="${H0_SRC_DIR%/*/*}"

## -------------------------------------------------------------------
## Configurable section

export M0_SRC_DIR=${M0_SRC_DIR:-${H0_SRC_DIR%/*}/mero}
[[ -d $M0_SRC_DIR ]]                || die "$M0_SRC_DIR: No such directory"
[[ -d $M0_SRC_DIR/mero ]]           || die "$M0_SRC_DIR: No Mero sources found"
[[ -x $M0_SRC_DIR/mero/.libs/m0d ]] || die "$M0_SRC_DIR: Mero is not built"
## -------------------------------------------------------------------

PROG="${0##*/}"
SUDO='sudo -E'

cmd_setup() {
    stack setup
}

_stack_build() {
    PKG_CONFIG_PATH=$M0_SRC_DIR \
    stack build --ghc-options="${GHC_OPTS:--g -j}" \
        --extra-include-dirs="$M0_SRC_DIR" \
        --extra-lib-dirs="$M0_SRC_DIR/mero/.libs" \
        "$@"
}

cmd_make() {
    _stack_build --test --no-run-tests "$@"
}

cmd_rebuild() {
    # XXX TODO: The script should be able to determine automatically
    # whether Mero has been updated since last Halon compilation.
    # One possible solution is to reimplement this script as a Makefile.
    stack clean rpclite
    cmd_make "$@"
}

cmd_test() {
    if [[ -n ${BRAVE_NEW_WORLD:-} ]]; then
        # Ideally we would use this command and run *all* unit tests.
        # Unfortunately, some of the tests fail.  XXX FIXME.
        LD_LIBRARY_PATH=$M0_SRC_DIR/mero/.libs _stack_build --test "$@"
    else
        LD_LIBRARY_PATH=$M0_SRC_DIR/mero/.libs \
        $H0_SRC_DIR/mero-halon/$(stack path --dist-dir)/build/tests/tests "$@"
    fi
}

local_install_root() {
    stack path --local-install-root
}

cmd_install() {
    $SUDO $H0_SRC_DIR/scripts/install-halon-services -l
    $SUDO $M0_SRC_DIR/scripts/install-mero-service -l
}

cmd_uninstall() {
    case ${1:-pass} in
        -c|--clean)
            $SUDO $M0_SRC_DIR/utils/m0setup --halon-facts --cleanup
            $SUDO systemctl start halon-cleanup
            $SUDO systemctl start mero-cleanup;;
        pass) ;;
        *) warn "[uninstall] Unknown option: $1";;
    esac

    $SUDO $M0_SRC_DIR/scripts/install-mero-service -u
    $SUDO $H0_SRC_DIR/scripts/install-halon-services -u
}

cmd_start() {
    cmd_uninstall
    cmd_install
    $SUDO systemctl start halon-cleanup
    $SUDO $M0_SRC_DIR/utils/m0setup --halon-facts --cleanup
    $SUDO $M0_SRC_DIR/utils/m0setup --halon-facts --clovis-apps
    $SUDO systemctl start halond
    halonctl mero bootstrap --verbose

    # Display bootstrap progress, usually it completes under a minute.
    { sleep 70; pkill -x watch; } &
    watch halonctl mero status

    local rc=0
    # Possible failure of m0t1fs has no impact on exit code of
    # `halonctl mero bootstrap` command above.
    if halonctl mero status | grep -q failed; then
        rc=1
    fi

    # Show final status (`watch` clears it's output after exit).
    halonctl mero status
    return $rc
}

cmd_stop() {
    halonctl mero stop
    halonctl mero status
    $SUDO systemctl stop halond
    $SUDO systemctl stop mero-kernel

    case ${1:-pass} in
        -u|--uninstall) cmd_uninstall --clean;;
        pass) ;;
        *) warn "[stop] Unknown option: $1";;
    esac
}

check_stack_dir() {
    [ -d ~/.stack ] ||
        die "Stack environment is not configured. Run \`$PROG setup' first."
}

cmd_path() {
    check_stack_dir
    echo "halon-bin: $(local_install_root)/bin"
    echo "mero-libs: $M0_SRC_DIR/mero/.libs"
}

cmd_env() {
    check_stack_dir
    echo "export PATH=\"$(local_install_root)/bin:\$PATH\""
    echo -n "export LD_LIBRARY_PATH=\"$M0_SRC_DIR/mero/.libs"
    echo "\${LD_LIBRARY_PATH:+:\$LD_LIBRARY_PATH}\""
}

cmd_clean() {
    stack clean "$@"
}

cmd_help() {
    local RET=${1:-0}

    [ $RET -eq 0 ] && usage || usage >&2
    exit $RET
}

_exec() {
    [[ $1 =~ ^cmd_(path|env|help)$ ]] || echo "----- ${@#cmd_} -----" >&2
    "$@"
}

usage() {
    cat <<EOF
Usage: $PROG {COMMAND [OPTION]...}...

Commands:
    setup                Get the appropriate GHC to build Halon.
                         (Rarely needed.)
    make [OPTION]...     Build Halon.
                         (Use \`$PROG rebuild' if Mero was updated.)
    rebuild [OPTION]...  Clean 'rpclite' module and build Halon.
    clean [OPTION]...    Clean local packages.
    test [OPTION]...     Run unit tests.
    start                Start cluster.
    stop [-u]            Stop cluster. \`stop -u' is equivalent to
                         \`stop uninstall -c'.
    install              Install Mero/Halon services and binaries.
    uninstall [-c]       Uninstall Mero/Halon services and binaries.
                         If \`-c' option is provided, clean Mero/Halon
                         metadata and configuration files before
                         uninstalling services.
    path                 Print out handy path information.
    env                  Print shell commands that, if evaluated, simplify
                         execution of Halon binaries located in the sources
                         directory.
    help                 Show this help and exit.

Options:
    'make', 'test', 'clean', and 'stack' commands support options of the
    Haskell Tool Stack. Type \`stack <command> --help' for the documentation.

Environment variables:
    M0_SRC_DIR    Path to Mero sources directory; defaults to '$M0_SRC_DIR'.
EOF
}

cd "$H0_SRC_DIR"

CMD=
OPTS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        setup|make|rebuild|test|path|env|clean|help) ;& # fall through
        install|uninstall|start|stop)
            [[ -z $CMD ]] || {
                if [[ ${#OPTS[@]} == 0 ]]; then
                    _exec $CMD
                else
                    _exec $CMD "${OPTS[@]}"
                fi
            }
            CMD=cmd_${1//-/_}
            OPTS=();;
        *)
            [[ -n $CMD ]] || {
                echo "Invalid command: $1" >&2
                die "Type \`$PROG help' for usage."
            }
            OPTS+=("$1");;
    esac
    shift
done
[[ -n $CMD ]] || cmd_help 1  # exits
if [[ ${#OPTS[@]} == 0 ]]; then
    _exec $CMD
else
    _exec $CMD "${OPTS[@]}"
fi
