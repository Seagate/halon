-- -*- outline-regexp: "-- #+" -*-

-- # TODO
--   * Q: How many racks?
--     A: m0genfacts creates only one rack with rack_idx=1.

let List/map = https://raw.githubusercontent.com/dhall-lang/dhall-lang/master/Prelude/List/map

----------------------------------------------------------------------
-- # XXX This data should be generated by `h0ist` script:

let _XXX_hostname = "cmu"
let _XXX_memsize_mb = 2846.65
let _XXX_cpucount = 3
let _XXX_mac = "00:0c:29:6a:ac:ae"
let _XXX_ip = "172.16.1.131"

----------------------------------------------------------------------
-- # Types

let Bmc = { bmc_addr : Text, bmc_user : Text, bmc_pass : Text }

let UNetKind = < Management | Data >

let UNetKind/show : UNetKind -> Text =
    \(x : UNetKind) ->
    let conv = { Management = "Management", Data = "Data" }
    in merge conv x

let Nic =
  { if_macAddress : Text
  , if_network : Text
  , if_ipAddrs : List Text
  }

let mkNic =
    \(mac : Text) ->
    \(ip : Text) ->
    \(kind : UNetKind) ->
  { if_macAddress = mac
  , if_network = UNetKind/show kind
  , if_ipAddrs = [ ip ]
  } : Nic

let URole = < Station | Ssu | Cmu | Dm >

let URole/show : URole -> Text =
    \(x : URole) ->
    let conv = { Station = "station", Ssu = "ssu", Cmu = "cmu", Dm = "dm" }
    in merge conv x

let Name = { name : Text }

let Host =
  { h_fqdn : Text
  , h_memsize : Double
  , h_cpucount : Natural
  , h_interfaces : List Nic
  , h_halon : { address : Text, roles : List Name }
  }

let mkHost
  = \(hostname : Text)     --%> Facter.value(:hostname)
 -> \(memsize_mb : Double) --%> Facter.value(:memorysize_mb)
 -> \(cpucount : Natural)  --%> Facter.value(:processors)['count']
                  --%> iface = Facter.value(:interfaces).split(',')[0]
 -> \(mac : Text) --%> Facter.value("macaddress_#{iface}")
 -> \(ip : Text)  --%> Facter.value("ipaddress_#{iface}")
 -> \(roles : List URole)
 ->
    let roleToName = \(x : URole) -> { name = URole/show x } : Name
    in
  { h_fqdn = hostname
  , h_memsize = memsize_mb
  , h_cpucount = cpucount
  , h_interfaces = [ mkNic mac ip UNetKind.Management
                   , mkNic mac ip UNetKind.Data
                   ]
  , h_halon = { address = ip ++ ":9000"
              , roles = List/map URole Name roleToName roles
              }
  } : Host

let Enclosure =
  { enc_idx : Natural
  , enc_id : Text
  , enc_bmc : List Bmc
  , enc_hosts : List Host
  }

let mkEnclosure
  = \(idx : Natural)
 -> \(hosts : List Host)
 ->
    let bmc = { bmc_addr = "0.0.0.0"
              , bmc_user = "admin"
              , bmc_pass = "admin"
              }
    in
  { enc_idx = idx
  , enc_id = "ENC#" ++ Natural/show idx
  , enc_bmc = [ bmc, bmc ]  -- XXX Do we really need two identical BMCs?
  , enc_hosts = hosts
  } : Enclosure

let Rack =
  { rack_idx : Natural
  , rack_enclosures : List Enclosure
  }

let Site =
  { site_idx : Natural
  , site_racks : List Rack
  }

-- # -----------------------------------------------------------------

let host =
    mkHost _XXX_hostname _XXX_memsize_mb _XXX_cpucount _XXX_mac _XXX_ip
        [ URole.Station, URole.Ssu ]

let enclosures = [ mkEnclosure 0 [ host ] ]

let rack = { rack_idx = 0, rack_enclosures = enclosures }
let site = { site_idx = 0, site_racks = [ rack ] }
in
  { id_sites = [ site ]
  --XXX , id_m0_servers = [ TODO Server ]
  -- XXX COMPLETEME
  -- , id_m0_globals
  -- , id_pools
  -- , id_profiles
  }
