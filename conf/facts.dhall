-- -*- outline-regexp: "-- #+" -*-

-- # TODO
--   * Q: How many racks?
--     A: m0genfacts creates only one rack with rack_idx=1.

let List/map = https://raw.githubusercontent.com/dhall-lang/dhall-lang/master/Prelude/List/map
let List/replicate = https://raw.githubusercontent.com/dhall-lang/dhall-lang/master/Prelude/List/replicate

let be_segment_size = 128 * 1024 * 1024  -- 128 MiB
let lnet_transport = "tcp"

----------------------------------------------------------------------
-- # XXX This data should be generated by `h0ist` script:

let _XXX_hostname = "cmu"
let _XXX_memsize_mb = 2846.65
let _XXX_memsize_kb = 2914304
let _XXX_cpucount = 3
let _XXX_mac = "00:0c:29:6a:ac:ae"
let _XXX_ip = "172.16.1.131"

----------------------------------------------------------------------
-- # Types

let Bmc = { bmc_addr : Text, bmc_user : Text, bmc_pass : Text }

let UNetKind = < Management | Data >

let UNetKind/show : UNetKind -> Text =
    \(x : UNetKind) ->
    let conv = { Management = "Management", Data = "Data" }
    in merge conv x

let Nic =
  { if_macAddress : Text
  , if_network : Text
  , if_ipAddrs : List Text
  }

let mkNic =
    \(mac : Text) ->
    \(ip : Text) ->
    \(kind : UNetKind) ->
  { if_macAddress = mac
  , if_network = UNetKind/show kind
  , if_ipAddrs = [ ip ]
  } : Nic

let URole = < Station | Ssu | Cmu | Dm >

let URole/show : URole -> Text =
    \(x : URole) ->
    let conv = { Station = "station", Ssu = "ssu", Cmu = "cmu", Dm = "dm" }
    in merge conv x

let Name = { name : Text }

let Host =
  { h_fqdn : Text
  , h_memsize : Double
  , h_cpucount : Natural
  , h_interfaces : List Nic
  , h_halon : { address : Text, roles : List Name }
  }

let mkHost
  = \(hostname : Text)     --%> `facter hostname`
 -> \(memsize_mb : Double) --%> `facter memorysize_mb`
 -> \(cpucount : Natural) --%> `facter --json processors | jq .processors.count`
                  --%> iface=`facter interfaces | cut -d, -f1`
 -> \(mac : Text) --%> `facter macaddress_${iface}`
 -> \(ip : Text)  --%> `facter ipaddress_${iface}`
 -> \(roles : List URole)
 ->
    let roleToName = \(x : URole) -> { name = URole/show x } : Name
    in
  { h_fqdn = hostname
  , h_memsize = memsize_mb
  , h_cpucount = cpucount
  , h_interfaces = [ mkNic mac ip UNetKind.Management
                   , mkNic mac ip UNetKind.Data
                   ]
  , h_halon = { address = ip ++ ":9000"
              , roles = List/map URole Name roleToName roles
              }
  } : Host

let Enclosure =
  { enc_idx : Natural
  , enc_id : Text
  , enc_bmc : List Bmc
  , enc_hosts : List Host
  }

let mkEnclosure
  = \(idx : Natural)
 -> \(hosts : List Host)
 ->
    let bmc = { bmc_addr = "0.0.0.0"
              , bmc_user = "admin"
              , bmc_pass = "admin"
              }
    in
  { enc_idx = idx
  , enc_id = "ENC#" ++ Natural/show idx
  , enc_bmc = [ bmc, bmc ]  -- XXX Do we really need two identical BMCs?
  , enc_hosts = hosts
  } : Enclosure

let Rack =
  { rack_idx : Natural
  , rack_enclosures : List Enclosure
  }

let Site =
  { site_idx : Natural
  , site_racks : List Rack
  }

let Server =
  { m0h_fqdn : Text
  , host_mem_as : Natural
  , host_mem_rss : Natural
  , host_mem_stack : Natural
  , host_mem_memlock : Natural
  , host_cores : List Natural
  , lnid : Text
  -- XXX TODO
  }

let mkServer
  = \(hostname : Text) --%> `facter hostname`
 -> \(memsize_kb : Natural) --%> memsize_mb=`facter memorysize_mb`
                            --%> `python -c "print(int(${memsize_mb}) * 1024)"`
 -> \(cpucount : Natural) --%> `facter --json processors | jq .processors.count`
 -> \(ip : Text)          --%> `facter ipaddress_${iface}`
 ->
  { m0h_fqdn = hostname
  , host_mem_as = be_segment_size
  , host_mem_rss = memsize_kb
  , host_mem_stack = memsize_kb
  , host_mem_memlock = memsize_kb
  , host_cores = List/replicate cpucount Natural 1
  , lnid = "${ip}@${lnet_transport}"
  -- XXX TODO
  }

let Facts =
  { id_sites : List Site
  , id_m0_servers : List Server
  }

-- # -----------------------------------------------------------------

let host =
    mkHost _XXX_hostname _XXX_memsize_mb _XXX_cpucount _XXX_mac _XXX_ip
        [ URole.Station, URole.Ssu ]
let server = mkServer _XXX_hostname _XXX_memsize_kb _XXX_cpucount _XXX_ip

let enclosures = [ mkEnclosure 0 [ host ] ]

let rack = { rack_idx = 0, rack_enclosures = enclosures }
let site = { site_idx = 0, site_racks = [ rack ] }
in
  { id_sites = [ site ]
  , id_m0_servers = [ server ]
  -- XXX COMPLETEME
  -- , id_m0_globals
  -- , id_pools
  -- , id_profiles
  } : Facts
